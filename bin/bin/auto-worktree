#!/usr/bin/env bash

set -Eeuo pipefail
trap cleanup SIGINT SIGTERM ERR EXIT

# script_dir=$(cd "$(dirname "${BASH_SOURCE[0]}")" &>/dev/null && pwd -P)

CWD=${PWD}
CWD_PARENT=$(readlink -f "$CWD/..")
# CWD_NAME=${PWD##*/}
PROGRAM_NAME=$(basename "$0")

usage() {
  cat <<EOF
$(tput bold)$(tput setaf 6)Git Worktree Manager$(tput sgr0)

$(tput bold)USAGE:$(tput sgr0)
  ${PROGRAM_NAME} <command> [options]

$(tput bold)COMMANDS:$(tput sgr0)
  $(tput setaf 2)switch$(tput sgr0)              Switch between existing worktrees using fuzzy finder
  $(tput setaf 2)new <name> [base]$(tput sgr0)   Create new worktree (optionally specify base branch)
  $(tput setaf 2)branch [name]$(tput sgr0)       Create or switch branches in current worktree
  $(tput setaf 2)list$(tput sgr0)                List all worktrees
  $(tput setaf 2)cleanup$(tput sgr0)             Remove completed/stale worktrees
  $(tput setaf 2)status$(tput sgr0)              Show status of all worktrees

$(tput bold)EXAMPLES:$(tput sgr0)
  git wt new feature-123         # Create new worktree for feature
  git wt switch                  # Interactive switch between worktrees
  git wt branch fix/bug-456     # Create/switch to branch in current worktree
  git wt cleanup                # Clean up old worktrees

$(tput bold)OPTIONS:$(tput sgr0)
  -h, --help     Show this help message
  -v, --verbose  Enable verbose output
EOF
  exit
}

function cwd_is_git_repo() {
  [ -d "$CWD/.git" ] && git rev-parse --is-inside-work-tree >/dev/null 2>&1
}

function prepare() {
  if [ ! "$(cwd_is_git_repo)" ] && [ -d "$CWD/main" ]; then
    cd main || exit 1
  fi
  git worktree prune
}

function cleanup() {
  trap - SIGINT SIGTERM ERR EXIT
  tput cnorm # enable cursor
}

setup_colors() {
  if [[ -t 2 ]] && [[ -z "${NO_COLOR-}" ]] && [[ "${TERM-}" != "dumb" ]]; then
    NOFORMAT='\033[0m' GRAY='\033[0;90m' RED='\033[0;31m' GREEN='\033[0;32m'
    ORANGE='\033[0;33m' BLUE='\033[0;34m' PURPLE='\033[0;35m' CYAN='\033[0;36m'
    YELLOW='\033[1;33m'
  else
    NOFORMAT='' GRAY='' RED='' GREEN='' ORANGE='' BLUE='' PURPLE='' CYAN='' YELLOW=''
  fi
}

function trim() {
  local var="$*"
  var="${var#"${var%%[![:space:]]*}"}"
  var="${var%"${var##*[![:space:]]}"}"
  echo -n "$var"
}

msg() {
  echo >&2 -e "${1-}"
}

info() {
  msg "${GRAY}[INFO]${NOFORMAT} ${1-}"
}

die() {
  local msg=$1
  local code=${2-1}
  msg "${RED}$msg${NOFORMAT}"
  exit "$code"
}

function spinner() {
  local LC_CTYPE=C
  local pid=$1
  local spin='⣾⣽⣻⢿⡿⣟⣯⣷'
  local charwidth=3

  local i=0
  tput civis
  while kill -0 "$pid" 2>/dev/null; do
    local i=$(((i + charwidth) % ${#spin}))
    printf >&2 "%s" "${spin:$i:$charwidth}"
    printf >&2 "\b"
    sleep .1
  done
  tput cnorm
  wait "$pid"
  return $?
}

run_command() {
  local message=$1
  shift
  echo >&2 -ne "$message "
  "$@" &>/dev/null &
  spinner $!
  if [ $? -eq 0 ]; then
    echo >&2 -e " ${GREEN}Done.${NOFORMAT}"
  else
    echo >&2 -e " ${RED}FAILED.${NOFORMAT}"
    exit 1
  fi
}

function handle_switch() {
  SELECTION=$(git worktree list | sed -r 's/^(.*\/([^[:space:]]* ))/\1 \2/g' |
    fzf --with-nth=2,4 --height 10 --border --prompt "Select worktree: ")
  if [ "$SELECTION" = "" ]; then
    exit 0
  fi
  DIR=$(cut -d" " -f1 <<<"$SELECTION")
  cd "$DIR" || die "Failed to change directory to $DIR"
  echo "$DIR"
}

function handle_new() {
  if [[ $# -lt 1 ]]; then
    die "${YELLOW}Usage: ${NOFORMAT}wt new <name> [base]${NOFORMAT}"
  fi

  local name="$1"

  # if we're already at the root of the worktree bare repo,
  # we can use the parent directory
  # else use the parent directory of the current working directory
  local worktree
  if git rev-parse --is-bare-repository >/dev/null 2>&1; then
    worktree="$CWD/$name"
  else
    worktree="$CWD_PARENT/$name"
  fi

  local base="${2:-$(git rev-parse --abbrev-ref HEAD)}"
  local branch="$name"

  if [[ -d "$worktree" ]]; then
    die "Worktree already exists: $worktree"
  fi

  # if branch already exists, error out
  if git show-ref --verify --quiet "refs/heads/$branch"; then
    die "Branch already exists: $branch"
  fi

  run_command "Creating worktree: $worktree with branch $branch" git worktree add -b "$branch" "$worktree" "$base" ||
    die "Failed to create worktree: $worktree"

  msg "${GRAY}Setting up worktree: $worktree${NOFORMAT}"
  cd "$worktree" || die "Failed to change directory"

  # Run any setup scripts if they exist
  if [[ -f "scripts/monorepo-setup.sh" ]]; then
    run_command "Running setup script" ./scripts/monorepo-setup.sh || die "Failed to run setup script"
    run_command "Running install" afm install platform || die "Failed to run afm install platform"
    info "platfrm install complete"
    info "installing jira"
    cd "jira" || die "Failed to change directory to jira"
    run_command "Running install" afm install jira || die "Failed to run afm install jira"
  fi

  msg "${GREEN}Worktree created successfully${NOFORMAT}"
}

function handle_branch() {
  local BRANCH=${1:-}
  local WORKTREE_NAME=$(basename "$PWD")

  if [ "$BRANCH" = "" ]; then
    # Show only branches relevant to current worktree
    BRANCH=$(trim "$(git for-each-ref --sort=-committerdate refs/heads/ --format='%(refname:short)' |
      grep "^$WORKTREE_NAME" |
      fzf --height=20% --reverse --info=inline)")
  fi

  if [ "$BRANCH" != "" ]; then
    if [ "$(git branch --list "$BRANCH")" ]; then
      run_command "Switching to $BRANCH" git checkout --ignore-other-worktrees "$BRANCH"
    else
      # Prefix branch with worktree name if not already
      [[ $BRANCH != $WORKTREE_NAME/* ]] && BRANCH="${WORKTREE_NAME}/${BRANCH}"
      run_command "Creating branch $BRANCH" git checkout --ignore-other-worktrees -b "$BRANCH"
    fi
  fi
}

function handle_list() {
  git worktree list |
    sed -r 's/^(.*\/([^[:space:]]* ))/\1 \2/g' |
    fzf --with-nth=2,4 --height 10 --border --prompt "Worktrees: "
}

function handle_cleanup() {
  echo "Select worktrees to remove (use TAB to select multiple):"
  git worktree list |
    grep -v "bare" |
    fzf --multi --height=20% --reverse |
    awk '{print $1}' |
    while read -r tree; do
      run_command "Removing worktree: $tree" git worktree remove --force "$tree"
    done
}

function handle_status() {
  echo "$(tput bold)Worktree Status:$(tput sgr0)"
  git worktree list

  echo -e "\n$(tput bold)Branch Status:$(tput sgr0)"
  git worktree list |
    grep -v "bare" |
    awk '{print $1}' |
    while read -r tree; do
      echo -e "\n$(tput setaf 6)$tree:$(tput sgr0)"
      (cd "$tree" && git status --short)
    done
}

function route_command() {
  local command="$1"
  shift
  case "$command" in
  switch)
    handle_switch "$@"
    ;;
  new)
    handle_new "$@"
    ;;
  branch)
    handle_branch "$@"
    ;;
  list)
    handle_list "$@"
    ;;
  cleanup)
    handle_cleanup "$@"
    ;;
  status)
    handle_status "$@"
    ;;
  *)
    die "Unknown command: $command"
    ;;
  esac
}

function main() {
  setup_colors

  if [[ $# -eq 0 ]]; then
    usage
  fi

  if [[ "$1" == "-h" || "$1" == "--help" ]]; then
    usage
  fi

  if [[ "$1" == "-v" || "$1" == "--verbose" ]]; then
    set -x
    shift
  fi

  route_command "$@"
}

main "$@"
